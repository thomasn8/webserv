TCP socket programming

1. Implement the Transport Layer of HTTP which is TCP

HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80, but other ports can be used.
All the famous HTTP servers like Apache Tomcat, NginX etc are implemented on top of TCP
HTTP/1.1: from RFC 7230 to RFC 7235 to implement basic workings of HTTP

To implement TCP, we have to learn TCP socket programming		
A socket is the mechanism that most popular operating systems provide to give programs access to the network. 
It allows messages to be sent and received between applications (unrelated processes) on different networked machines.
The sockets mechanism has been created to be independent of any specific type of network. 
IP, however, is by far the most dominant network and the most popular use of sockets.
	
	Socket-layer functions:
		These functions are used by the user process to send or receive
		packets and to do other socket operations.  For more information
		see their respective manual pages.

		socket(2) creates a socket, connect(2) connects a socket to a
		remote socket address, the bind(2) function binds a socket to a
		local socket address, listen(2) tells the socket that new
		connections shall be accepted, and accept(2) is used to get a new
		socket with a new incoming connection.  socketpair(2) returns two
		connected anonymous sockets (implemented only for a few local
		families like AF_UNIX)

		send(2), sendto(2), and sendmsg(2) send data over a socket, and
		recv(2), recvfrom(2), recvmsg(2) receive data from a socket.
		poll(2) and select(2) wait for arriving data or a readiness to
		send data.  In addition, the standard I/O operations like
		write(2), writev(2), sendfile(2), read(2), and readv(2) can be
		used to read and write data.

		getsockname(2) returns the local socket address and
		getpeername(2) returns the remote socket address.  getsockopt(2)
		and setsockopt(2) are used to set or get socket layer or protocol
		options.  ioctl(2) can be used to set or read some other options.

		close(2) is used to close a socket.  shutdown(2) closes parts of
		a full-duplex socket connection.

		It is possible to do nonblocking I/O on sockets by setting the
		O_NONBLOCK flag on a socket file descriptor using fcntl(2).  Then
		all operations that would block will (usually) return with EAGAIN
		(operation should be retried later); connect(2) will return
		EINPROGRESS error.  The user can then wait for various events via
		poll(2) or select(2).

	Socket address structures:
		Each socket domain has its own format for socket addresses, with
		a domain-specific address structure.  Each of these structures
		begins with an integer "family" field (typed as sa_family_t) that
		indicates the type of the address structure.  This allows the
		various system calls (e.g., connect(2), bind(2), accept(2),
		getsockname(2), getpeername(2)), which are generic to all socket
		domains, to determine the domain of a particular socket address.

		To allow any type of socket address to be passed to interfaces in
		the sockets API, the type struct sockaddr is defined.  The
		purpose of this type is purely to allow casting of domain-
		specific socket address types to a "generic" type, so as to avoid
		compiler warnings about type mismatches in calls to the sockets
		API.
			REF: https://man7.org/linux/man-pages/man7/socket.7.html

	Todo:
		1.1 Create the socket
		1.2 Identify the socket
		1.3 On the server, wait for an incoming connection
		1.4 Send and receive messages
		1.5 Close the socket

	References:
		https://man7.org/linux/man-pages/man7/socket.7.html
		https://man7.org/linux/man-pages/man2/socket.2.html
		https://man7.org/linux/man-pages/man7/ip.7.html
		https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa
		https://www.linuxhowtos.org/C_C++/socket.htm
		http://dwise1.net/pgm/sockets/blocking.html
		https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.1 Create the socket
	Create an endpoint for communication and returns a file descriptor that refers to that endpoint.
	The analogy of creating a socket is that of requesting a telephone line from the phone company.
	A socket system call:
		int socket(int domain, int type, int protocol)
	where
		domain: 		specifies a communication domain that selects the protocol family which will be used for communication
		type: 			type of service according to the properties required by the application which specifies the communication semantics
		protocol: 		indicate a specific protocol to use in supporting the sockets operation
		Return value: 	a file descriptor (small integer) or -1. 
	
	for TCP/IP sockets we want to specify the domain as IP address family (IPv4 Internet protocols): 	AF_INET 
	the type as sequenced, reliable, two-way, connection-based byte streams (virtual circuit service): 	SOCK_STREAM
		
		Sockets of type SOCK_STREAM are full-duplex byte streams. They do not preserve record boundaries.
		[= Les sockets de type SOCK_STREAM sont des flux d'octets en duplex. Elles ne préservent pas les limites d'enregistrement]
		A stream socket must be in a connected state before any data may be sent or received on it.
		A connection to another socket is created with a connect(2) call.
		Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.
		When a session has been completed a close(2) may be performed.
		Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2).

		The communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.
		If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered to be dead. 
		When SO_KEEPALIVE is enabled on the socket the protocol checks in a protocol-specific manner if the other end is still alive.  
		A SIGPIPE signal is raised if a process sends or receives on a broken stream; this causes naive processes, which do not handle the signal, to exit.
		
{}	CODE LOOKS LIKE:
		#include <sys/socket.h>
		#include <netinet/in.h>
		int server_fd;
		if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
		{
			perror(“cannot create socket”); 
			return 0; 
		}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.2 Identify the socket
	When a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it.
	bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.
	This operation is called “assigning a name to a socket”
	It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections 
	The analogy is that of assigning a phone number to the line that you requested from the phone company 

	A bind system call:
		int bind(int socket, const struct sockaddr *address, socklen_t address_len);
	where 
		socket: 		the socket that was created with the socket system call
		sockaddr: 		is a generic container that just allows the OS to be able to read the first couple of bytes that identify the address family
		address_len: 	specifies the size, in bytes, of the address structure pointed to by sockaddr
		Return value: 	0 (success) / -1 (error)

	sockaddr container:
		struct sockaddr_in 
		{ 
			__uint8_t         sin_len;
			sa_family_t       sin_family; 				// address family to set up the socket 						=> AF_INET
			in_port_t         sin_port; 				// port number (or transport address) 						=> 0
			struct in_addr    sin_addr; 				// The address for this socket: the machine’s IP address 	=> INADDR_ANY
			char              sin_zero[8]; 
		};
	where
		Family:
			Same as domain in socket()
		Port:
			You can explicitly assign a transport address (port) or allow the operating system to assign one.
			If you’re a client and won’t be receiving incoming connections, you’ll usually just let the operating system pick any available port number by specifying port 0. 
			If you’re a server, you’ll generally pick a specific number since clients will need to know a port number to connect to.
		Addr:
			Most of the time, we don’t care to specify a specific interface and can let the operating system use whatever it wants. 
			The special address for this is 0.0.0.0, defined by the symbolic constant INADDR_ANY
			When a process wants to receive new incoming packets or connections only one IP socket may be bound to any given local (address, port) pair 
			When INADDR_ANY is specified in the bind call, the socket will be bound to all local interfaces.

{}	CODE LOOKS LIKE:
		... 
		struct sockaddr_in address;
		const int PORT = 8080;
		memset((char *)&address, 0, sizeof(address)); 
		address.sin_family = AF_INET; 
		address.sin_addr.s_addr = htonl(INADDR_ANY); 
		address.sin_port = htons(PORT); 
		/* 
			htonl converts a long integer (e.g. address) to a network representation
			htons converts a short integer (e.g. port) to a network representation 
		*/ 
		if (bind(server_fd,(struct sockaddr *)&address,sizeof(address)) < 0) 
		{ 
			perror(“bind failed”); 
			return 0; 
		}

	A TCP local socket address that has been bound is unavailable for some time after closing, unless the SO_REUSEADDR flag has been set.
	Care should be taken when using this flag as it makes TCP less reliable.

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.3 On the server, wait for an incoming connection
