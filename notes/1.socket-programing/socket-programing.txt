TCP socket programming

1. Implement the Transport Layer of HTTP which is TCP

HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80, but other ports can be used.
All the famous HTTP servers like Apache Tomcat, NginX etc are implemented on top of TCP
HTTP/1.1: from RFC 7230 to RFC 7235 to implement basic workings of HTTP

To implement TCP, we have to learn TCP socket programming		
A socket is the mechanism that most popular operating systems provide to give programs access to the network. 
It allows messages to be sent and received between applications (unrelated processes) on different networked machines.
The sockets mechanism has been created to be independent of any specific type of network. 
IP, however, is by far the most dominant network and the most popular use of sockets.
	
	Functions needed:
		socket()
		bind()
		htonl()
		htons()
	
	Struct used:
		sockaddr_in{}

	Todo:
		1.1 Create the socket
		1.2 Identify the socket
		1.3 On the server, wait for an incoming connection
		1.4 Send and receive messages
		1.5 Close the socket

	References:
		https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa
		https://www.linuxhowtos.org/C_C++/socket.htm
		http://dwise1.net/pgm/sockets/blocking.html
		https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.1 Create the socket
	The analogy of creating a socket is that of requesting a telephone line from the phone company.
	A socket system call:
		int socket(int domain, int type, int protocol)
	where
		domain: communication domain in which the socket should be created
		type: type of service according to the properties required by the application
		protocol: indicate a specific protocol to use in supporting the sockets operation
	Return value is a file descriptor (small integer). 
	
	for TCP/IP sockets we want to specify the IP address family (AF_INET) and virtual circuit service (SOCK_STREAM)
		
{}	CODE LOOKS LIKE:
		#include <sys/socket.h>
		int server_fd;
		if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
		{
			perror(“cannot create socket”); 
			return 0; 
		}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.2 Identify the socket
	The analogy is that of assigning a phone number to the line that you requested from the phone company 
	Assign a transport address to the socket: a port number in IP networking. 
	In sockets, this operation is called binding an address and the bind system call is used for this.

	A bind system call:
		int bind(int socket, const struct sockaddr *address, socklen_t address_len);
	where 
		socket: the socket that was created with the socket system call
		sockaddr: is a generic container that just allows the OS to be able to read the first couple of bytes that identify the address family
		address_len: specifies the size, in bytes, of the address structure pointed to by sockaddr
	Return value 0 (success) / -1 (error)

	Instead of accepting a port number as a parameter the interface is very general. 
	It takes a sockaddr structure whose actual format is determined on the address family (type of network) you're using. 
	For example, if you're using UNIX domain sockets, bind actually creates a file in the file system.
	The address family determines what variant of the sockaddr struct to use that contains elements that make sense for that specific communication type. 
	For IP networking, we use struct sockaddr_in, which is defined in the header netinet/in.h:
		
		struct sockaddr_in 
		{ 
			__uint8_t         sin_len;
			sa_family_t       sin_family; 				// address family to set up the socket 						=> AF_INET
			in_port_t         sin_port; 				// port number (or transport address) 						=> 0
			struct in_addr    sin_addr; 				// The address for this socket: the machine’s IP address 	=> INADDR_ANY
			char              sin_zero[8]; 
		};
	
	You can explicitly assign a transport address (port) or allow the operating system to assign one.
	If you’re a client and won’t be receiving incoming connections, you’ll usually just let the operating system pick any available port number by specifying port 0. 
	If you’re a server, you’ll generally pick a specific number since clients will need to know a port number to connect to.
	Most of the time, we don’t care to specify a specific interface and can let the operating system use whatever it wants. 
	The special address for this is 0.0.0.0, defined by the symbolic constant INADDR_ANY

{}	CODE LOOKS LIKE:
		... 
		struct sockaddr_in address;
		const int PORT = 8080;
		memset((char *)&address, 0, sizeof(address)); 
		address.sin_family = AF_INET; 
		address.sin_addr.s_addr = htonl(INADDR_ANY); 
		address.sin_port = htons(PORT); 
		/* 
			htonl converts a long integer (e.g. address) to a network representation
			htons converts a short integer (e.g. port) to a network representation 
		*/ 
		if (bind(server_fd,(struct sockaddr *)&address,sizeof(address)) < 0) 
		{ 
			perror(“bind failed”); 
			return 0; 
		}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.3 On the server, wait for an incoming connection