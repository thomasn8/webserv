Blocking. You’ve heard about it—now what the heck is it? In a nutshell, “block” is techie jargon
for “sleep”. You probably noticed that when you run listener , above, it just sits there until a
packet arrives. What happened is that it called recvfrom() , there was no data, and so
recvfrom() is said to “block” (that is, sleep there) until some data arrives.

Lots of functions block. accept() blocks. All the recv() functions block. The reason they can do
this is because they’re allowed to. When you first create the socket descriptor with socket() , the
kernel sets it to blocking. If you don’t want a socket to be blocking, you have to make a call to
fcntl() :

	fcntl(sockfd, F_SETFL, O_NONBLOCK);

By setting a socket to non-blocking, you can effectively “poll” the socket for information. If you
try to read from a non-blocking socket and there’s no data there, it’s not allowed to block—it will
return -1 and errno will be set to EAGAIN or EWOULDBLOCK .

(Wait—it can return EAGAIN or EWOULDBLOCK ? Which do you check for? The specification doesn’t
actually specify which your system will return, so for portability, check them both.)

Generally speaking, however, this type of polling is a bad idea. If you put your program in a busywait
looking for data on the socket, you’ll suck up CPU time like it was going out of style. A more
elegant solution for checking to see if there’s data waiting to be read comes in the following
section on poll()


/* ******* ACCEPT ******* */
	int newfd = accept(master_socket, (struct sockaddr *) &remoteaddr, (socklen_t *) &remoteaddr.sin_len);

If no pending connections are present on the queue, and the socket is not marked as non-blocking, accept() blocks the caller until a connection is present.
If the socket is marked non-blocking and no pending connections are present on the queue, accept() returns an error as described below.
The accepted socket may not be used to accept more connections. The original socket socket, remains open.
The call returns -1 on error and the global variable errno is set to indicate the error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.
The accept() system call will fail if:
[EWOULDBLOCK]      socket is marked as non-blocking and no connections are present to be accepted.

/* ******* POLL ******* */
	int	poll(struct pollfd fds[], nfds_t nfds, int timeout);

poll() examines a set of file descriptors to see if some of them are ready for I/O or if certain events have occurred on them. The fds argument is a pointer to an
array of pollfd structures, as defined in ⟨poll.h⟩ (shown below). The nfds argument specifies the size of the fds array.

	struct pollfd {
		int    fd;       /* file descriptor: File descriptor to poll */
		short  events;   /* events to look for: Events to poll for. */
		short  revents;  /* events returned: Events which may occur or have occurred*/
	};

The event bitmasks in events and revents have the following bits:
POLLIN		Data other than high priority data may be read without blocking.  This is equivalent to ( POLLRDNORM | POLLRDBAND ).
POLLOUT		Normal data may be written without blocking.  This is equivalent to POLLWRNORM.

If timeout is greater than zero, it specifies a maximum interval (in milliseconds) to wait for any file descriptor to become ready.
If timeout is zero, then poll() will return without blocking.
If the value of timeout is -1, the poll blocks indefinitely.

poll() returns the number of descriptors that are ready for I/O, or -1 if an error occurred.  If the time limit expires, poll() returns 0.  If poll() returns with an
error, including one due to an interrupted call, the fds array will be unmodified and the global variable errno will be set to indicate the error.

/* ******* SELECT ******* */
	select(fdmax+1, &ready_fds, NULL, NULL, NULL)

This function is somewhat strange, but it’s very useful. Take the following situation: you are a
server and you want to listen for incoming connections as well as keep reading from the
connections you already have.
No problem, you say, just an accept() and a couple of recv() s. Not so fast, buster! What if
you’re blocking on an accept() call? How are you going to recv() data at the same time? “Use
non-blocking sockets!” No way! You don’t want to be a CPU hog. What, then?
select() gives you the power to monitor several sockets at the same time. It’ll tell you which
ones are ready for reading, which are ready for writing, and which sockets have raised exceptions,
if you really want to know that.

If timeout is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If timeout is a null pointer, the select blocks indefinitely.
To effect a poll, the timeout argument should be not be a null pointer, but it should point to a zero-valued timeval structure.