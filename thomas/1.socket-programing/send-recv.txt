7.4 Handling Partial send() s

Remember back in the section about send() , above, when I said that send() might not send all
the bytes you asked it to? That is, you want it to send 512 bytes, but it returns 412. What
happened to the remaining 100 bytes?
Well, they’re still in your little buffer waiting to be sent out. Due to circumstances beyond your
control, the kernel decided not to send all the data out in one chunk, and now, my friend, it’s up
to you to get the data out there.

You could write a function like this to do it, too:

	int sendall(int s, char *buf, int *len)
	{
		int total = 0; // how many bytes we've sent
		int bytesleft = *len; // how many we have left to send
		int n;

		while(total < *len) 
		{
			n = send(s, buf+total, bytesleft, 0);
			if (n == -1) { break; }
			total += n;
			bytesleft -= n;
		}

		*len = total; // return number actually sent here

		return n==-1?-1:0; // return -1 on failure, 0 on success
	}

Call the function:

char buf[10] = "Beej!";
int len;
len = strlen(buf);
if (sendall(s, buf, &len) == -1)
{
	perror("sendall");
	printf("We only sent %d bytes because of the error!\n", len);
}

What happens on the receiver’s end when part of a packet arrives? If the packets are variable
length, how does the receiver know when one packet ends and another begins? Yes, real-world
scenarios are a royal pain in the donkeys. You probably have to encapsulate (remember that from
the data encapsulation section way back there at the beginning?) Read on for details!

What does it really mean to encapsulate data, anyway? In the simplest case, it means you’ll stick a
header on there with either some identifying information or a packet length, or both.

You could, if you wanted, make all messages the same length and just call the sendall() we implemented,
above. But that wastes bandwidth! We don’t want to send() 1024 bytes just so “tom” can say “Hi”.

So we encapsulate the data in a tiny header and packet structure. Both the client and server know
how to pack and unpack (sometimes referred to as “marshal” and “unmarshal”) this data. Don’t
look now, but we’re starting to define a protocol that describes how a client and server
communicate!

When you’re sending this data, you should be safe and use a command similar to sendall() ,
above, so you know all the data is sent, even if it takes multiple calls to send() to get it all out.
Likewise, when you’re receiving this data, you need to do a bit of extra work. To be safe, you
should assume that you might receive a partial packet. We need to call recv() over
and over again until the packet is completely received.
But how? Well, we know the number of bytes we need to receive in total for the packet to be
complete, since that number is tacked on the front of the packet. We also know the maximum
packet size is 1+8+128, or 137 bytes (because that’s how we defined the packet).
There are actually a couple things you can do here. Since you know every packet starts off with a
length, you can call recv() just to get the packet length. Then once you have that, you can call it
again specifying exactly the remaining length of the packet (possibly repeatedly to get all the
data) until you have the complete packet. The advantage of this method is that you only need a
buffer large enough for one packet, while the disadvantage is that you need to call recv() at least
twice to get all the data.

Another option is just to call recv() and say the amount you’re willing to receive is the
maximum number of bytes in a packet. Then whatever you get, stick it onto the back of a buffer,
and finally check to see if the packet is complete. Of course, you might get some of the next
packet, so you’ll need to have room for that.

I’m sending a slew of data, but when I recv() , it only receives 536 bytes or 1460
bytes at a time. But if I run it on my local machine, it receives all the data at the
same time. What’s going on?
You’re hitting the MTU—the maximum size the physical medium can handle. On the local
machine, you’re using the loopback device which can handle 8K or more no problem. But on
Ethernet, which can only handle 1500 bytes with a header, you hit that limit. Over a modem, with
576 MTU (again, with header), you hit the even lower limit.
You have to make sure all the data is being sent, first of all. (See the sendall() function
implementation for details.) Once you’re sure of that, then you need to call recv() in a loop until
all your data is read.
Read the section Son of Data Encapsulation for details on receiving complete packets of data
using multiple calls to recv() .